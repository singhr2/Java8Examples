[1] Functional Interfaces (@FunctionalInterface annotation) / 
   Single Abstract Method interfaces (SAM Interfaces)
------------------------------------------------------------
  * Only 1 Single abstract method (SAM)
  * 0..* default and/or static methods
  
  Note: It is different from 'Marker Interface' which don't have any method at all

---------------------------------------------
[2] Functional Interfaces provided by Java 8
---------------------------------------------
* Supplier
  
* Consumer

* Function
  public <R> apply(T parameter);

  >> Function Composition: compose(), andThen()
  
  
* Predicate
  boolean test(T t);
  
  e.g., Predicate<String> startsWithA = (text) -> text.startsWith("A");
 
  >> Predicate Composition: and(), or() 
  //example credit: http://tutorials.jenkov.com/java-functional-programming/functional-composition.html#predicate-composition
  Predicate<String> startsWithA = (text) -> text.startsWith("A");
  Predicate<String> endsWithX   = (text) -> text.endsWith("x");
  Predicate<String> composedUsingAnd = startsWithA.and(endsWithX);
  Predicate<String> composedUsingOr = startsWithA.or(endsWithX);

---------------------------------------------
[3] Lambda 
---------------------------------------------
  * Annonymous function - don't belong to any class, can be passed around methods
  * Lambda Expressions
  * Lambda Functions
  >>
    // Test online using https://www.compilejava.net/
    
    @FunctionalInterface
    interface TestFIa{
      void printMessage(String str);
    }

    @FunctionalInterface
    interface TestFIb{
        void execute(String s1);
    }

    public class HelloWorld{
      public static void main(String... args){
        System.out.println("Welcome");
        
        //Lambda Function
        TestFIa fia = (s) -> {
         System.out.println(s);
        };

        //Lambda Expression
        TestFIb fib = System.out::println;

        //Invoke
        fia.printMessage("Hello World using Lambda Function");
        fib.execute("Hello World using Lambda Expression");
        }
    }

----------------------------------------------
[4] Default(aka Defender) and Static methods in Interfaces
----------------------------------------------
* we CANNOT make Default method static in Java
     static default void find(){...}
* An interface can contain more than one Default methods
* Default method cannot override any method from java.lang.Object
* static method of interface can't be overriden in implementing classes (to be verified)

----------------------------------------------
[5] Streams
----------------------------------------------
* stream() - sequential stream
* parallelStream()

Operations:
* Intermediate operations : 
   >> always return a new stream
   >> don't process the elements until a terminal operation is invoked, in other words, they're lazy.
   >>>> stateless and stateful operations.
     Stateless operations :
     retain no state from previously elements when processing a new element 
     so each can be processed independently of operations on other elements.

     Stateful operations:
     such as distinct and sorted, may incorporate state from previously seen elements when processing new elements.
  
  >>>> 
  * map():
  * filter():
  * limit():
  * sorted():
  
  
   
* Terminal operations
   >> forEach()
   >> count()
   >> collect()
   >>toArray()
   etc.
 
 
 
----------------------------------------------
[6] java.util.Optional<T>
----------------------------------------------
<!> @SeeAlso https://dzone.com/articles/using-optional-correctly-is-not-optional

* Optional is intended to provide a limited mechanism for "library method return types" 
  where there needed to be a clear way to represent “no result," and 
  using null for such was overwhelmingly likely to cause errors.
           - "Brian Goetz, Java’s language architect"
* to express the potential absence of a value with a data-type  

<!!!>
* Use Optional to communicate an intended possible absence of a value (e.g. the return value of a function).

* Avoid having Optionals as method argument

* Avoid Optional Types in Object Fields, they are not serializable
  WRONG ::  private Optional<Engine> engine;
  
* Do Not Use Optional in Constructors Arguments

* Do Not Use Optional in Setters Arguments
  private Optional<String> postcode; // optional field, thus may be null

* Avoid Collection of Optionals
  WRONG:: private List<Optional<Wheel>> wheels;

* Never Assign Null to an Optional Variable
   WRONG: Optional<Cart> emptyCart = null;
   CORRECT: Optional<Cart> emptyCart = Optional.empty();

* Avoid Optional::isPresent followed by Optional::get

* Avoid complex or state changing calculations in orElse. Use orElseGet for that

* Any expression you put inside orElse() is always evaluated (eagerly). 

  
  
  
* Methods:
  >> Optional.isPresent()
     Better to use ifPresent(statement-to-execute);
     
  >> Optional.isEmpty() : Since Java 11 { opposite of isPresent() }
  
  >> Optional.get()
     only return a value if the wrapped object is not null, 
     otherwise, it throws java.util.NoSuchElementException
     
  >> Optional.orElse()  <-- eager : see above notes ; Used to pass Default Value
      String nullName = null;
      String name = Optional.ofNullable(nullName).orElse("john");
      
  >> Optional.orElseGet(Supplier)  <-- better option than orElse() <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
      String nullName = null;
      String name = Optional.ofNullable(nullName).orElseGet(() -> "john");
      
  >> orElseThrow() : Instead of returning a default value when the wrapped value is not present, it throws an exception
     String nullName = null;
     String name = Optional.ofNullable(nullName).orElseThrow( IllegalArgumentException::new );
     
     In Java 10, for  java.util.NoSuchElementException, use  orElseThrow()
      
  >> Optional.ofNullable(valueOrNull).ifPresentOrElse( this::doSomethingWithPresentValue, this::doSomethingElse);
  
* Creating Optional:
  >> Optional.empty() : 
  >> Optional.of(T value) : <-- T can't be null
  >> Optional.ofNullable(T value) : <- in case we expect some null values, will returns an empty Optional object it T is null
     
     Optional.of(null)will throwNullPointerException, while 
     Optional.ofNullable(null) will result in an Optional.empty.
     


